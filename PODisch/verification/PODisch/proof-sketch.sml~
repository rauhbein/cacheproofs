(* ------------------------------------------------------------------- 
   Axioms
   ------------------------------------------------------------------- *)

 (* No aliasing inside the kernel *)
val no_aliasing_kernel_axiom = new_axiom("no_aliasing_kernel_axiom",
  ``!va va' rs req. 
   let (p1, a1) = THE (rtranslation(rs, va , K, req)) in
   let (p2, a2) = THE (rtranslation(rs, va', K, req)) in
   (p1 = p2) ==> ((a1 = a2) /\ (va = va'))``
);

 (* Physical address in the current request is the translation of its virtual address *)
val req_pa_drivd_req_va_axiom = new_axiom("req_pa_drivd_req_va_axiom",
  ``!rs em req. (rs.ms.MC.curr.desc.paddress, rs.ms.MC.curr.desc.memattrs.inner.attrs) 
                = THE(rtranslation(rs, rs.ms.MC.curr.va, em, req))``
);

(* ------------------------------------------------------------------- 
   Definitions
   ------------------------------------------------------------------- *)

val cr_coherent_axiom = new_axiom("cr_coherent_axiom",
   ``!va pa ms state. let (i, t, wi) = lineSpec(va, pa) state in 
    CrResource(pa) ==>  
    (~LineDirty(i,t, ms.CACHE)) ==> 
    (CellRead(i, t, wi, ms.CACHE) = (v2w(read_mem32(pa, ms.PM)):word32))``
);


 (* redefining the real_state *)
val _ = Hol_datatype `real_state =
  <| ms      : MEM_SYSTEM;
     cc      : CORE_CONFIG
  |>`;

val cohere_prop_def = Define`
  cohere_prop dc  pm state (res:resource_class#word48) = 
   let (cls, pa) = res in
   let (i, t, wi)  = lineSpec(0w, pa) state in
   (~LineDirty(i,t, dc) ) ==> (CellRead(i, t, wi, dc) = v2w(read_mem32(pa, pm)))`;

val cacheable_def = Define`cacheable cbl = ((cbl = 3w) \/ (cbl = 2w))`;

val drivedByInvariant_real_inst_def = Define` drivedByInvariant_real_inst (rs:real_state) =
    !va (req:access_type) state.
     (let (pa, cbl) = THE (rtranslation(rs, rs.cc.PC, K, req)) in KMemory((memory, pa))) /\
     (cohere (rdomain(rs, cr) ∪ rgcr(rs)) (cohere_prop rs.ms.CACHE rs.ms.PM state)) /\
     (let (_, cbl) = THE (rtranslation(rs, va, K, req)) in (cacheable cbl))
`;

val drivedByInvariant_isa_inst_def = Define` drivedByInvariant_isa_inst (is:real_state) =
    !va (req:access_type).
     (let (pa, cbl) = THE (rtranslation(is, is.cc.PC, K, req)) in KMemory((memory, pa))) /\
     (let (_, cbl) = THE (rtranslation(is, va, K, req)) in (cacheable cbl))
`;


(* ------------------------------------------------------------------- 
   Proof
   ------------------------------------------------------------------- *)
val writeReq_paHitdc'_thm = Q.prove(
  `!(va:word64) (pa:word48) data ms bs cbl state.
   let ms' = writeReq(bs, cbl, va, pa, data, ms) state in   
   ((cbl = 2w) \/ (cbl = 3w)) ==>
    (Hit(va, pa, ms'.CACHE) state)`,

    fs_lambda_elim[Hit_def, writeReq_def, write_cache_def]
    \\ rw[]
    \\ EVAL_TAC
    \\ THM_SPECL_GOAL "CacheWrite" cacheWrite_paHitdc'_thm [``state:dharma8_state``] 
    \\ undisch_all_tac >> fs_lambda_elim[Hit_def] >> fs[]
);



local
  val undisch_case_tac  = undisch_hd_tac \\ CASE_TAC \\ PAIR_SPLIT_TAC \\ lrw []
(* FIRST & SECOND SUBGOALs attrs = 2w \/ 3w *)
  val cbl_subgoal_tac = 
      undisch_all_tac
   \\ fs_lambda_elim[readReq_def, read_cache_def]
   \\ lrw[]
   \\ EVERY[rpt CASE_TAC
     \\ Q.UNABBREV_TAC`ms'`
     \\ PAIR_SPLIT_TAC
     \\ Q.ABBREV_TAC`crr = (CacheRead (s1.MC.curr.va,s1.MC.curr.desc.paddress,r1.PM,r1.CACHE) state)`
     \\ THM_SPECL_ASSM "CacheRead" CacheRead_lfoldEQval_thm [`va`, `pa`, `state`]
     \\ Cases_on`s1.MC.curr.desc.paddress ≠ pa` \\ rfs[]
     \\ (THM_SPECL_ASSM "CacheRead" CacheRead_vaEQva'_thm  [`va`, `state`] \\ fs[])
     \\ THM_SPECL_ASSM "CacheRead" CacheRead_lfoldEQval_SameAddress_thm [`state`]
     \\ rfs[]]

(* THIRD SUBGOAL attrs <> 2w /\ 3w *)
  val ncbl_subgoal_tac = 
      undisch_all_tac
   \\ fs_lambda_elim[readReq_def, read_cache_def]
   \\ lrw[]
   \\ rfs[Abbr`ms'`]
   \\ PAIR_SPLIT_TAC \\ rfs[]
   \\ (fn (asl, g) => let val trm = find_term is_cacheRead g in (Q.ABBREV_TAC`crr = ^trm state`) (asl, g) end)
   \\ rpt CASE_TAC
   \\ (THM_SPECL_ASSM "CacheRead" CacheRead_vaEQva'_thm  [`va`, `state`] \\ fs[])
   \\ EVERY[ THM_SPECL_ASSM "CacheRead" Mem_CacheRead_lfold_diffAddress_thm [`va`, `pa`, `state`]
   \\ rfs[]]


in

(* (! pa attrs .  *)
(*   (v2w(read_mem(0w:word32, pa, s1.PM)):word32  *)
(*     = v2w(SND(readReq(4n,  attrs, pa, r1)  state)))) ==>  *)

val reply_thm = Q.store_thm("reply_thm",
 ``!(s1:real_state) (r1:real_state) (state:dharma8_state). 
    let (smr, sms) = replyseq(nofault, s1.ms) in 
    let (rmr, rms) = reply(nofault, r1.ms) state in
     (drivedByInvariant_real_inst r1) ==>
     (drivedByInvariant_isa_inst s1)  ==>
     invariant_mem                    ==>
     invariant_cache                  ==>
     (r1.ms.TZC = s1.ms.TZC)          ==> 
     (r1.ms.MC.S = mem_serve)         ==>
     (r1.ms.MC.curr.bytesize = 4)     ==>
     (r1.ms.MC.curr  = s1.ms.MC.curr) ==> 
     (LENGTH s1.ms.MC.curr.data = 32) ==> 
     (r1.ms.MC.curr.acctype  =  AccType_NORMAL) ==>
     (r1.ms.MC.curr.write = access_policy(r1.ms.MC.curr.desc.paddress, T))  ==>

     (!va pa attrs req.   
       ((pa, attrs) = THE(rtranslation(r1, va, K, req)))  ==>
       (smember(rgcr(r1) ∪ rdomain(r1, cr), (memory, pa))) ==> 
       (v2w(read_mem(0w:word32, pa, s1.ms.PM)):word32 = v2w(SND(readReq(4n,  attrs, va, pa, r1.ms)  state)))) ==>

     (!va pa attrs req.
       ((pa, attrs) = THE(rtranslation(r1, va, K, req)))  ==>
       (smember(rgcr(r1) ∪ rdomain(r1, cr), (memory, pa))) ==> 
       (v2w(read_mem(0w:word32, pa, sms.PM)):word32  = v2w(SND(readReq(4n,  attrs, va, pa, rms)  state)))
     )``;

    lrw[]
    \\ PairedLambda.GEN_BETA_TAC
    \\ rpt strip_tac
    \\ xfs [replyseq_def, reply_def, Once LET_DEF]
    \\ CASE_TAC
    \\ fs[LET_DEF]
    \\ qpat_assum `!x y. P` (qspecl_then [`va`, `pa`, `attrs`, `req`] assume_tac)
(* ---------------------- first sub-goal ------------------------------ *)
    >-(assume_tac(readReq_NOTCHGmc_thm
         |> spec_let_elim [`va`, `pa`, `attrs`, `r1.ms`, `r1.ms with MC := r1.ms.MC with S := mem_wait`, `state`])
    \\ Cases_on`r1.ms.MC = r1.ms.MC with S := mem_wait`    
    >-(assume_tac (readReq_NOTCHGconfigS_thm  
       |> spec_let_elim [`s1.ms.MC.curr.va`, `s1.ms.MC.curr.desc.paddress`,
                    `s1.ms.MC.curr.desc.memattrs.inner.attrs`, `r1.ms`, `state`] 
       |> LET_ELIM_RULE)
    \\ REABBREV_TAC
    \\ `(r1.ms.MC with S := mem_wait).S = mem_wait` by fs[]
    \\ SYM_ASSUMPTION_TAC ``r1.ms.MC = r1.ms.MC with S := mem_wait``
    \\ FULL_SIMP_TAC(bool_ss) []
    \\ `mem_wait <> mem_serve` by EVAL_TAC
    \\ rfs[])
    \\ lfs[])
(* --------------------------- end ----------------------------------- *)

    \\ assume_tac(readMem_readReq_eq_NotDirty_thm |> spec_let_elim [`va`, `pa`, `attrs`, `state`, `r1.ms`])
    \\ (BasicProvers.EVERY_CASE_TAC
    \\ rfs_lambda_elim [read_cache_def,read_mem32_thm])

(* ---------------------- write sub-goal------------------------------ *)

    >-( (fn (asl, g) => let val _::trm::_ = find_terms is_writeReq g in (Q.ABBREV_TAC `ms' = (^trm state)`) (asl, g) end) 
    \\ assume_tac(readReq_NOTCHGmc_thm
            |> spec_let_elim [`va`, `pa`, `attrs`, `ms'`, `ms' with MC := ms'.MC with S := mem_wait`, `state`])
    
    \\ Cases_on`ms'.MC = ms'.MC with S := mem_wait`
    >-(THM_SPECL_ASSM "writeReq" writeReq_NOTCHGconfigS_thm [`state`]
    \\ `(ms'.MC with S := mem_wait).S = mem_wait` by fs[]
    \\ SYM_ASSUMPTION_TAC ``ms'.MC = ms'.MC with S := mem_wait``
    \\ FULL_SIMP_TAC(bool_ss) []
    \\ `mem_wait <> mem_serve` by EVAL_TAC)
    \\ lfs[]
    \\ SYM_ASSUMPTION_TAC``SND(x) = SND(y)``
    \\ fs[]
    \\ THM_SPECL_GOAL "write_mem" write_mem32_thm2 [] >> fs[]

(* Doing case analysis on the equality of physical addresses*)
    \\ (Cases_on`s1.ms.MC.curr.desc.paddress = pa` >> fs[])
    \\ assume_tac(req_pa_drivd_req_va_axiom |> spec_let_elim[`r1:real_state`, `K`, `req`]) >> rfs[]
    \\ assume_tac (no_aliasing_kernel_axiom |> INST_TYPE[alpha |-> ``:real_state``]
                  |> spec_let_elim[`va`, `s1.ms.MC.curr.va`, `r1:real_state`, `req`])
    \\ PAIR_SPLIT_TAC
    \\ rfs[]


    >-( simp[readReq_def, read_cache_def]
       \\ PairedLambda.GEN_BETA_TAC
       \\ BasicProvers.EVERY_CASE_TAC  

   

(* --------------------------- `s1.ms.MC.curr.desc.paddress = pa` ----------------------------------- *)
 \\ assume_tac (writeReq_paHitdc'_thm |> spec_let_elim [`va`, `pa`, `s1.ms.MC.curr.data`, `r1.ms`, `4:num`, `3w`, `state`])
 \\ rfs[]
 \\ rw[]
 \\ UNDISCH_MATCH_TAC``a = b``
 \\ fs_lambda_elim[CacheRead_def, combinTheory.UPDATE_def, Touch_def]
 \\ rfs[]
 \\ lrw[]
 \\ fs[field_id_imp, Abbr`ms'`]
 \\ abr_lineSpec_tac_sgl
 \\ simp[writeReq_def, write_cache_def]
 \\ PairedLambda.GEN_BETA_TAC
 \\ fs[Once state_transformerTheory.FOR_def, state_transformerTheory.BIND_DEF]

 \\ THM_SPECL_GOAL "CacheWrite" cacheWrite_read_thm [``state:dharma8_state``]
 \\ THM_SPECL_GOAL "CacheWrite" cacheWrite_paHitdc'_thm [``state:dharma8_state``]
 \\ ntac 2 (UNDISCH_MATCH_TAC ``a``)
 \\ fs_lambda_elim[CacheRead_def, combinTheory.UPDATE_def, Touch_def]
 \\ lrw[]
 \\ abr_tac_goal is_fst "pa" NONE
 \\ assume_tac(write_read_thm |> spec_let_elim[`pa`, `v2w s1.ms.MC.curr.data`, `s1.ms.PM`]) >> fs[]
 \\ fs[field_id_imp]

 \\ fs[drivedByInvariant_real_inst_def, cacheable_def]
 \\ qpat_assum`!a. b`(qspecl_then [`va`, `req`, `state`] assume_tac)
 \\ PAIR_SPLIT_TAC
 \\ rfs[]

(* --------------------------- `s1.ms.MC.curr.desc.paddress <> pa` ----------------------------------- *)
   rw[]
 \\ abr_tac_goal is_fst "pa" NONE
 \\ WEAKEN_TAC is_imp

assume_tac(
cache_writeReq_readReq_DiffAdr_thm |> spec_let_elim[`4n`, `SND (THE (rtranslation ((r1:real_state),va,K,req)))`, `va`, `pa`, `r1.ms`, `s1.ms.MC.curr.data`, `s1.ms.MC.curr.va`, `s1.ms.MC.curr.desc.paddress`, `state`])

THM_SPECL_GOAL "readReq"  [``s1.ms.MC.curr.data``, ``s1.ms.MC.curr.va``, ``s1.ms.MC.curr.desc.paddress``, ``state:dharma8_state``]

rfs[]
REABBREV_TAC
(* --------------------------- end ----------------------------------- *)
    (* Read sub goal *)  
    \\ (fn (asl, g) => let val _::trm::_ = find_terms is_readReq g in (Q.ABBREV_TAC `ms' = FST(^trm state)`) (asl, g) end) 
    \\ assume_tac(readReq_NOTCHGmc_thm
            |> spec_let_elim [`va`, `pa`, `attrs`, `ms'`, `ms' with MC := ms'.MC with S := mem_wait`, `state`])
    
    \\ Cases_on`ms'.MC = ms'.MC with S := mem_wait`
    >-(assume_tac (readReq_NOTCHGconfigS_thm  
           |> spec_let_elim [`s1.MC.curr.va`, `s1.MC.curr.desc.paddress`, `s1.MC.curr.desc.memattrs.inner.attrs`, `r1`, `state`] |> LET_ELIM_RULE)
    \\ REABBREV_TAC
    \\ `(ms'.MC with S := mem_wait).S = mem_wait` by fs[]
    \\ SYM_ASSUMPTION_TAC ``ms'.MC = ms'.MC with S := mem_wait``
    \\ FULL_SIMP_TAC(bool_ss) []
    \\ `mem_wait <> mem_serve` by EVAL_TAC)
    \\ lfs[]
    \\ SYM_ASSUMPTION_TAC``SND(x) = SND(y)``
    \\ fs[]
    \\ simp_tac(srw_ss()) [readReq_def, LET_DEF]
    \\ PairedLambda.GEN_BETA_TAC
    \\ (BasicProvers.EVERY_CASE_TAC  \\ rfs_lambda_elim[read_cache_def])
    >|[ cbl_subgoal_tac, cbl_subgoal_tac, ncbl_subgoal_tac])

end;

