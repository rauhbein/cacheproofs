open HolKernel boolLib bossLib Parse;
open wordsTheory wordsLib;


val writeMem_tm     = prim_mk_const {Name="write_mem",   Thy="dharma8"}
val dest_writeMem   = dest_monop writeMem_tm (ERR "dest_writeMem" "")
val is_writeMem     = can dest_writeMem

val readMem_tm      = prim_mk_const {Name="read_mem",   Thy="dharma8"}
val dest_readMem    = dest_monop readMem_tm (ERR "dest_readMem" "")
val is_readMem      = can dest_readMem


val readReq_tm     = prim_mk_const {Name="readReq",   Thy="dharma8"}
val dest_readReq    = dest_monop readReq_tm (ERR "dest_readReq" "")
val is_readReq      = can dest_readReq

val writeReq_tm     = prim_mk_const {Name="writeReq",   Thy="dharma8"}
val dest_writeReq   = dest_monop writeReq_tm (ERR "dest_writeReq" "")
val is_writeReq     = can dest_writeReq

val writeBackLine_tm       = prim_mk_const {Name="WriteBackLine",   Thy="dharma8"}
val dest_writeBackLine     = dest_monop writeBackLine_tm (ERR "dest_writeBackLine" "")
val is_writeBackLine       = can dest_writeBackLine

val evict_tm       = prim_mk_const {Name="Evict",   Thy="dharma8"}
val dest_evict     = dest_monop evict_tm (ERR "dest_evict" "")
val is_evict       = can dest_evict

val lineFill_tm       = prim_mk_const {Name="LineFill",   Thy="dharma8"}
val dest_lineFill     = dest_monop lineFill_tm (ERR "dest_lineFill" "")
val is_lineFill       = can dest_lineFill

val Fill_tm       = prim_mk_const {Name="Fill",   Thy="dharma8"}
val dest_Fill     = dest_monop Fill_tm (ERR "dest_Fill" "")
val is_Fill       = can dest_Fill


val cacheRead_tm       = prim_mk_const {Name="CacheRead",   Thy="dharma8"}
val dest_cacheRead     = dest_monop cacheRead_tm (ERR "dest_cacheRead" "")
val is_cacheRead       = can dest_cacheRead


val abr_lineSpec_tac_dubl =
 (fn (asl, g) => let val a::b::_ = rm_dup (find_terms ifilter g)
		     val c::d::_ = rm_dup (find_terms tfilter g)
		in (Q.ABBREV_TAC `i'= ^a`  \\ Q.ABBREV_TAC `t' = (FST ^c)` \\ Q.ABBREV_TAC `wi' = (SND ^c)`
                 \\ Q.ABBREV_TAC `i = ^b`  \\ Q.ABBREV_TAC `t = (FST ^d)`  \\ Q.ABBREV_TAC `wi = (SND ^d)`)
 (asl ,g) end);


val abr_lineSpec_tac_sgl =
 (fn (asl, g) => let val a::_ = rm_dup (find_terms ifilter g)  val c::_ = rm_dup (find_terms tfilter g)
		in (Q.ABBREV_TAC `i' = ^a`  \\ Q.ABBREV_TAC `t' = (FST ^c)` \\ Q.ABBREV_TAC `wi' = (SND ^c)`)
 (asl ,g) end);


(* To prove that line  size is lee that 2 ** 15 *)
fun line_size_lt_dimword15 nl =
      `2 ** ^nl ≤ 32769` by (all_tac
    \\ assume_tac(Drule.ISPECL[``(state :dharma8_state).DC.ctr.DminLine``](w2n_lt) |> SIMP_RULE(srw_ss())[])
    \\ `w2n state.DC.ctr.DminLine <= 15`  by decide_tac
    \\ `!a b. a <= b ==> 2**a <= 2**b` by FULL_SIMP_TAC(arith_ss)[]
    \\ REABBREV_TAC
    \\ qpat_assum `!a b. P` (qspecl_then [`^nl`, `15n`] assume_tac)
    \\ res_tac
    \\ `(2 ** ^nl ≤ 2 ** 15) ==> (2 ** ^nl < (2 ** 15) + 1)` by FULL_SIMP_TAC (bool_ss)[]
    >|[(qspecl_then [`2 ** ^nl`, `2 ** 15`] assume_tac) arithmeticTheory.LE_LT1
    \\ res_tac
    \\ FULL_SIMP_TAC (arith_ss)[], all_tac]
    \\ fs[]);

val set_size_lt_48 = 
    SUBGOAL_THEN ``w2n (word_log2 (state.DC.ccsidr.NumSets)) + 1 < 48`` (fn thm => assume_tac thm)
    >- (xfs[word_log2_def]
       \\ (qspecl_then [`state.DC.ccsidr.NumSets `] assume_tac) (INST_TYPE [alpha |-> ``:15``]LOG2_w2n_lt)
       (* \\ `(state.DC.ccsidr.NumSets ≥ 0w) ==> (state.DC.ccsidr.NumSets + 1w ≠ 0w)` by blastLib.BBLAST_TAC *)
       \\ res_tac
       \\ rfs[invariant_cache_def]);


(* --------------------------------------------------------------------------------------------- *)

val write_mem32_def = Define `
write_mem32 (add:bool[48], (pm:(word48->word8)), value:bool[32]) =
  let pm = (add =+ ((7 >< 0) value):word8)      pm in
  let pm = (add+1w =+ ((15 >< 8) value):word8)  pm in
  let pm = (add+2w =+ ((23 >< 16) value):word8) pm in
  let pm = (add+3w =+ ((31 >< 24) value):word8)pm in
      pm
`;

val write_read_thm = Q.store_thm("write_read_thm", `
 !a v m. 
   (let m' = write_mem32(a,m,v) in
      (read_mem32(a,m') = w2v v))`,
       rpt GEN_TAC
    \\ EVAL_TAC
    \\ lfs[read_mem32_def, combinTheory.UPDATE_def]
    \\ rpt (CASE_TAC >- FIRST_ASSUM (fn thm => let val trm = concl thm in `~^trm` by blastLib.BBLAST_TAC end))
    \\ fs[w2v_def]
    \\ blastLib.BBLAST_PROVE_TAC
);


val write_read_unch_thm = Q.store_thm("write_read_unch_thm", `
  !a a' v m m'.
  (a' + 3w <+ a /\ a' + 3w >=+ 3w /\ a + 3w >=+ 3w) \/
  (a' >+ a + 3w /\ a' + 3w >=+ 3w /\ a + 3w >=+ 3w) ==>
  (m' = write_mem32(a,m,v)) ==>
  (read_mem32(a',m') = read_mem32(a',m))`,
       rpt GEN_TAC
    \\ EVAL_TAC
    \\ rw[read_mem32_def]
    \\ fs[combinTheory.UPDATE_def]
    \\ EVERY[rpt (CASE_TAC >- (FIRST_ASSUM (fn thm => let val trm = concl thm in `~^trm` by FULL_SIMP_TAC(bool_ss)[] end)
                              \\ schneiderUtils.UNDISCH_ALL_TAC
			      \\ blastLib.BBLAST_PROVE_TAC))
   ]);

(* --------------------------------------------------------------------------------------------- *)

local 
 fun termExt trm res n =  
    case n of 0 => res 
    | _  => let val (trm, trm') = dest_comb  trm 
	    in
		termExt (trm') [trm] (n -1)
	    end
 fun SYM_ASM_TAC pat =  PAT_ASSUM pat (fn thm => let val cnl = concl thm 
				   val (a1,a2) = dest_eq cnl
                                   val new_thm = SPECL [a1,a2] (Thm.INST_TYPE[alpha |-> (type_of a1)] EQ_SYM)
				   val (_, rh)= (dest_imp o concl) new_thm
				in
				   (ASSUME_TAC  thm)
                                   THEN (ASSUME_TAC new_thm)
				   THEN `^rh` by METIS_TAC []
				   THEN FULL_SIMP_TAC (srw_ss()) []
				end)
 fun wt_mem_eq_tac a b n= 
   (fn (asl, w) =>
        let val (a1,a2) = dest_eq w
	val l = (snd o dest_comb o hd) (termExt a1 [] n)
	val r = (snd o dest_comb o hd) (termExt a2 [] n) 
        in (`^l = ^r` by FULL_SIMP_TAC (bool_ss) []) (asl, w)  end)
  \\ ASSUME_SPECL_TAC [``^a``, ``^b``, `` (w2v (data:word32))``] (INST_TYPE [alpha |-> ``:32``, beta |-> ``:8``] 
     extract_v2w)
  \\ `LENGTH (w2v (data :word32)) ≤ dimindex ((:32) :32 itself)` by (blastLib.BBLAST_TAC
          \\ ASSUME_SPEC_TAC ``data:word32`` (INST_TYPE [alpha |-> ``:32`` ]w2v_def)
          \\ fs[])
  
  \\ fs[]
  \\ SYM_ASM_TAC ``a = b``
  \\ fs []
  \\ blastLib.BBLAST_TAC
in 
 val write_mem32_thm = Q.store_thm("write_mem32_thm",
  `! (pa:word48) (data:word32)  (mc:MEM_CONFIG) (pm:(word48->word8)).
   let (mc', pm1) = write_mem(0w:word32, pa, w2v(data), mc, pm) in 
   let pm2 = write_mem32(pa, pm, data) in 
       pm1 = pm2`,

   rw_tac (srw_ss())[]
  \\ fs [write_mem32_def , write_mem_def]
  \\ (NTAC 4 (fs[Once state_transformerTheory.FOR_def, state_transformerTheory.BIND_DEF]))
  \\ rw_tac (srw_ss())[]
  \\ unabbrev_all_tac
  \\ fs[]
  \\ wt_mem_eq_tac ``(31:num)`` ``(24:num)`` 1
  \\ wt_mem_eq_tac ``(23:num)`` ``(16:num)`` 2
  \\ wt_mem_eq_tac ``(15:num)`` ``(8:num)`` 3
  \\ wt_mem_eq_tac ``(7:num)`` ``(0:num)`` 4
)


val write_mem32_thm2 = Q.store_thm("write_mem32_thm2",
 `! (pa:word48) (data:bitstring)  (mc:MEM_CONFIG) (pm:(word48->word8)).
   let (mc', pm1) = write_mem(0w:word32, pa, data, mc, pm) in 
   let pm2 = write_mem32(pa, pm, v2w(data):(word32)) in
    (LENGTH data ≤ dimindex (:32)) ==> (pm1 = pm2)`,

       rw_tac (srw_ss())[]
    \\ fs [write_mem32_def , write_mem_def]
    \\ (NTAC 4 (fs [Once state_transformerTheory.FOR_def, state_transformerTheory.BIND_DEF]))
    \\ xrw[]
    \\ unabbrev_all_tac
    \\ fs[combinTheory.UPDATE_def]
    \\ MAP_EVERY (fn (a,b) => assume_tac(extract_v2w
	|> INST_TYPE [alpha |-> ``:32``, beta |-> ``:8``] 
	|> Q.ISPECL[`^a`,`^b`,`data:bitstring`]
     )) [(``31n``,``24n``), (``23n``, ``16n``), (``15n``, ``8n``), (``7n``, ``0n``)]
    \\ rfs[] 
)
end;

(* --------------------------------------------------------------------------------------------- *)
val read_mem32_thm = Q.store_thm("read_mem32_thm",
 `!pa:word48 (pm:(word48->word8)). read_mem(0w:word32, pa, pm) = read_mem32(pa, pm)`,

     fs [read_mem32_def, read_mem_def]
  \\ EVAL_TAC
  \\ blastLib.BBLAST_TAC);

(* --------------------------------------------------------------------------------------------- *)
val wrtBck_dirtybit_thm = Q.store_thm("wrtBck_dirty_thm",
    `!i:(48 word) t:(48 word) (pm:(word48->word8)) (dc:(48 word -> CSET)) (n:num) (state:dharma8_state). 
    (let (dc', pm') =  WriteBackLine(i, t, pm, dc, n) state in 
     ((n <= dimword(:15)) ==>
       (!wi:num. (wi <= n) ==> (~LineDirty(i, t,  dc')) )))`,
      
        lrw[]
     \\ lfs [WriteBackLine_def, Once LET_DEF, FOR_FOLDL]
     \\ (EVAL_TAC \\ fs[LET_DEF, LineDirty_def, WriteBack_def, combinTheory.UPDATE_def])
);

(* --------------------------------------------------------------------------------------------- *)

fun abr_suc_tac sn = `(w2n (word_log2 state.DC.ccsidr.NumSets) + 3n) = (^sn + 2n)` by rfs[Abbr`^sn`] \\ xfs[];

val lt_mod_thm = Q.store_thm("lt_mod_thm",
 `!a b c d. ((a < b) /\ (b <= c) /\ (c < d)) ==> ((a MOD d) < (b MOD d))`,
     fs []);

val adr_neq2_thm = Q.store_thm("adr_neq2_thm",
  `!(a:word48) (b:word48) (c:word48) (n:num). 
   let bmM = ((0xffffffffffffw:word48) >>> n) in
   let bmL = ~((0xffffffffffffw:word48) >>> n << n) in
  ((n < 48)) ==>  
  ((a && bmM = a) /\ (b && bmL = b) /\ (c && bmL = c)) ==>
  (b <> c) ==>   
  (((a << n) !! b) <> ((a << n) !! c))`,

  ntac 3 strip_tac
  \\ ntac 48 (Induct_on `n`
   THENL[fs[] \\ blastLib.BBLAST_PROVE_TAC,  
	 fs[] \\ PAT_ASSUM ``a``(fn thm => all_tac)])
);

val numeral_tac = (
           abr_suc_tac ``sn``
       \\  ASSUME_TAC((SPECL[``(w2w((n2w wi :48 word) ) : word48)``, 
                         ``(w2w ((n2w ((n :num) + (1 :num)) :48 word)) :word48)``]
              (INST_TYPE [alpha |-> ``:48``](GSYM WORD_LO)) ) |> SIMP_RULE (srw_ss()) [w2n_w2w])

      \\ ASSUME_TAC(SPECL[``wi:num``, ``(n:num)+1``, ``dimword(:16)``, ``dimword(:48)``]lt_mod_thm)
      \\ rfs []
      \\ PAT_ASSUM``a <+ b``(fn thm => let val asm = concl thm  val ls = (snd o strip_comb) asm
			     val t1 = (snd o dest_comb) (hd ls )val t2 = (snd o dest_comb) (hd (tl ls) )
			     in
			      assume_tac(thm) \\ assume_tac(blastLib.BBLAST_PROVE``^asm ==> ^t2 <> ^t1``)
			     end
			    )

      \\ res_tac
      \\ `((n2w ((n :num) + (1 :num)) :48 word) ≠ (n2w (wi :num) :48 word)) /\ (wi < dimword(:15)) /\ (n+1 <= dimword(:15)) ==>
           ((n2w ((n :num) + (1 :num)) :48 word) << 2) <> ((n2w (wi :num) :48 word) << 2)` by 
         (fs [word_lsl_n2w] \\ xrw [] \\ fs[])
      \\ rfs[]
      \\ `wi < 32768` by decide_tac
      \\ qpat_assum `!i t wi ni nt s. P` (qspecl_then [`i`, `t`, `wi`, `ln' + 2n`, `sn`, `state`] ASSUME_TAC)
      \\ rpt (WEAKEN_TAC is_forall)
      \\ xfs[invariant_cache_def]
      \\ qpat_assum `!i t wi ni nt s. P` (qspecl_then [`i`, `t`, `n+1`, `ln' + 2n`, `sn`, `state`] ASSUME_TAC)
      \\ rpt (WEAKEN_TAC is_forall)
      \\ xfs[LET_DEF]
      \\ assume_tac(adr_neq2_thm |> spec_let_elim [`(i ‖ t ≪ sn)`, `n2w (n + 1) ≪ 2`, `n2w wi ≪ 2`, `(ln' + 2)`])
      \\ assume_tac(SPECL[``(state :dharma8_state).DC.ctr.DminLine``](INST_TYPE[alpha |-> ``:4``]w2n_lt) |> SIMP_RULE(srw_ss())[])
      \\ `ln' + 2 < 48` by decide_tac
      \\ rfs[]
);

val wrtBck_memory_thm = Q.store_thm("wrtBck_memory_thm",
 `!i:(48 word) t:(48 word) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state) (n:num).
    (let (dc', pm') =  WriteBackLine(i, t, pm, dc, n) state in
     let sn = w2n (word_log2 (state.DC.ccsidr.NumSets)) + 1 in
     let ln = (w2n state.DC.ctr.DminLine) in
     (n <= dimword(:15) ==> (!wi:num. wi <= n ==>
          let pa = ((t << (sn + ln + 2)) !! (i << (ln + 2)) !! (n2w(wi):(48 word) << 2)) in
           (invariant_cache) ==>
	   (CellRead(i, t, wi, dc') = v2w(read_mem32(pa, pm')))
     )))`,

       xrw []
    \\ fs [WriteBackLine_def, CellRead_def ,FOR_FOLDL, combinTheory.UPDATE_def]
    \\ lrw[]

    >- (Induct_on `n`
     >-(EVAL_TAC
        \\ rfs[read_mem32_def, combinTheory.UPDATE_def]
	\\ strip_tac
	\\ unabbrev_all_tac
  	\\ ntac 4 ((fn (asl, g) =>
                let val (t,_,_) = (dest_cond o repeat (snd  o wordsSyntax.dest_word_concat) o snd o dest_eq) g in
	        `~^t` by  (fs [] \\ blastLib.BBLAST_TAC) end (asl, g))
	        \\ fs [])
	\\ blastLib.BBLAST_TAC)
      (* Inductive step *)
      \\ rpt strip_tac
      \\ `n ≤ 32768` by decide_tac
      \\ fs[DECIDE``SUC n = n + 1``]
      \\ ASSUME_TAC( rich_listTheory.COUNT_LIST_ADD
			 |> Q.ISPECL[`(n:num) + 1`, `1:num`]
			 |> SIMP_RULE(srw_ss())[listTheory.MAP, EVAL ``COUNT_LIST  (1)``])

      \\ lfs []
      \\ rfs[rich_listTheory.FOLDL_APPEND |> SIMP_RULE(srw_ss())[]]
      \\ abr_tac listSyntax.is_foldl
      \\ THM_KEEP_TAC ``invariant_cache`` (xfs [invariant_cache_def])
      \\ simp[CellRead_def, read_mem32_def]
      \\ qpat_assum `∀s:dharma8_state s':dharma8_state. P` (qspecl_then[`(SND (SND (SND (SND abr))))`,`state`] assume_tac)
      \\ xfs[]
      \\ Cases_on `wi ≤ n`
      THENL[xfs[]
           \\ simp[combinTheory.UPDATE_def]
           \\ (fn (asl, g) => let val t = (find_term is_eq o snd o dest_eq)g in (Cases_on`^t`) (asl, g)end)
	   THENL[xfs [Abbr`pa`]
	     \\ ntac 3 ((fn (asl, g) => let val t = (find_terms is_eq o snd o dest_eq)g
			 in (MAP_FIRST (fn z =>  `~^z` by blastLib.BBLAST_TAC) t) (asl, g) end)
		        \\ xfs[])
	     \\ (ASSUME_TAC (DECIDE ``((wi:num) ≤ n + 1) ==> ((wi< n + 1)\/ (wi = n + 1))``)
             \\ res_tac THENL[numeral_tac, fs[]]) ,
	   xfs [Abbr`pa`] \\ abr_suc_tac ``sn``
	 \\ (fn (asl, g) => let val t = (find_terms is_eq o snd o dest_eq)g
		in (MAP_EVERY (fn z =>  `~^z` by blastLib.BBLAST_TAC) t) (asl, g) end)
	 \\ xfs [read_mem32_def]],
         `(wi = n + 1)` by decide_tac 
	 \\ simp[WriteBack_def, combinTheory.UPDATE_def]
	 \\ xfs[Abbr`pa`] \\ abr_suc_tac ``sn``
         \\ (fn (asl, g) => let val t = (find_terms is_eq o snd o dest_eq)g
	      	in (MAP_EVERY (fn z =>  `~^z` by blastLib.BBLAST_TAC) t) (asl, g) end)
	 \\ rfs[]
	 \\ blastLib.BBLAST_TAC])
	      
       \\ xfs[invariant_cache_def]
       \\ qpat_assum`∀i' t' wi' dc' pm sn' ln. P`(qspecl_then[`i`, `t`, `wi`, `dc`, `pm`, `sn`, `ln'`] assume_tac)
       \\ rfs[LineDirty_def, CellRead_def]
);

val WriteBackLine_simp_def = Define`
    WriteBackLine_simp (li,t,pm,dc,n) =
     (let v = (dc li).sl
      in
        ((li =+
          dc li with sl := (t =+ SOME (THE (v t) with dirty := F)) v)
           dc,pm))
`;

val WriteBackLine_Dont_change_cache_value = Q.prove(
   `!i:(48 word) t:(48 word) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state) (n:num).
    (let (dc', _) =  WriteBackLine(i, t, pm, dc, n) state in
     let (dc'', _) =  WriteBackLine_simp(i, t, pm, dc, n) in
     let sn = w2n (word_log2 (state.DC.ccsidr.NumSets + 1w)) in
     let ln = (w2n state.DC.ctr.DminLine) in
     (n <= dimword(:15) ==>  (((dc' i).sl t) = ((dc'' i).sl t))))`,

       xrw []
    \\ fs [WriteBackLine_simp_def, WriteBackLine_def, CellRead_def ,FOR_FOLDL, combinTheory.UPDATE_def]
    \\ lrw[]

    \\ Induct_on `n`

    >- (EVAL_TAC)
    \\ fs[DECIDE``SUC n = n + 1``, FOR_FOLDL]
    \\ ASSUME_TAC( rich_listTheory.COUNT_LIST_ADD
			 |> Q.ISPECL[`(n:num) + 1`, `1:num`]
			 |> SIMP_RULE(srw_ss())[listTheory.MAP, EVAL ``COUNT_LIST  (1)``])
    \\ rfs[rich_listTheory.FOLDL_APPEND |> SIMP_RULE(srw_ss())[]] 
);

val WriteBackLine_CellRead_dcEQdc'_thm = Q.prove(
    `!i:(48 word) t:(48 word) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state) (n:num).
    (let (dc', _) =  WriteBackLine(i, t, pm, dc, n) state in
    ((n <= dimword(:15)) ==> (!wi:num. wi <= n ==>
     (CellRead(i,t,wi, dc) = CellRead(i,t,wi, dc'))				 
    )))`,
          xrw[CellRead_def]
       \\ assume_tac (WriteBackLine_Dont_change_cache_value |> spec_let_elim[`i`, `t`, `pm`, `dc`, `state`, `n`])
       \\ rfs[]
       \\ lrw[WriteBackLine_simp_def,  combinTheory.UPDATE_def, CellRead_def]
);

val wrtBckLine_dcEQpm'_thm = Q.store_thm("wrtBckLine_dcEQpm'_thm",
  `!i:(48 word) t:(48 word) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state) (n:num).
    (let (dc', pm') =  WriteBackLine(i, t, pm, dc, n) state in
     let sn = w2n (word_log2 (state.DC.ccsidr.NumSets)) + 1 in
     let ln = (w2n state.DC.ctr.DminLine) in
     (n <= dimword(:15) ==> (!wi:num. wi <= n ==>
          let pa = ((t << (sn + ln + 2)) !! (i << (ln + 2)) !! (n2w(wi):(48 word) << 2)) in
           (invariant_cache) ==>
	   (CellRead(i, t, wi, dc) = v2w(read_mem32(pa, pm')))
     )))`,

    xrw[]
    \\ imp_res_tac (wrtBck_memory_thm |> SIMP_RULE(srw_ss())[LET_DEF] |> PairedLambda.GEN_BETA_RULE)
    \\ qpat_assum`!x. P`(qspecl_then[`t`, `state`, `pm`, `i`, `dc`] assume_tac)
    \\ REABBREV_TAC

    \\ imp_res_tac (WriteBackLine_CellRead_dcEQdc'_thm |> SIMP_RULE(srw_ss())[LET_DEF] |> PairedLambda.GEN_BETA_RULE)
    \\ qpat_assum`!x. P`(qspecl_then[`t`, `state`, `pm`, `i`, `dc`] assume_tac)
    \\ rfs[]
);

val WriteBackLine_Dont_change_Mem_IfNotDirty_thm = Q.prove(
   `!(i:word48) (t:word48) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state) n.
    (let (dc', pm')  =  WriteBackLine(i, t, pm, dc, n) state in
     let (dc'',pm'') =  WriteBackLine_simp(i, t, pm, dc, n) in
     let sn = w2n (word_log2 (state.DC.ccsidr.NumSets + 1w)) in
     let ln = (w2n state.DC.ctr.DminLine) in
     (~LineDirty(i, t, dc)) ==>
     (!pa'. v2w(read_mem32(pa', pm')):word32 = v2w(read_mem32(pa', pm'')))
    )`,

       xrw []
    \\ fs_lambda_elim [WriteBackLine_simp_def, WriteBackLine_def, CellRead_def ,FOR_FOLDL, combinTheory.UPDATE_def, LineDirty_def]
);

val wrtBckLine_pmEQpm'IfNotDirty_thm = Q.store_thm("wrtBckLine_pmEQpm'IfNotDirty_thm",
   `!(i:word48) (t:word48) (pm:(word48->word8)) (dc:(48 word -> CSET)) n (state:dharma8_state).
    (let (_, pm') =  WriteBackLine(i, t, pm, dc, n) state in
     (~LineDirty(i, t, dc)) ==>
     (!pa'. (v2w(read_mem32(pa', pm)):word32 = v2w(read_mem32(pa', pm'))))
    )`,

       xrw[]
    \\ assume_tac(WriteBackLine_Dont_change_Mem_IfNotDirty_thm |> spec_let_elim [`i`, `t`, `pm`, `dc`, `state`, `n`])
    \\ rfs[]
    \\ qpat_assum`!a. P`(qspecl_then[`pa`] assume_tac)
    \\ fs[WriteBackLine_simp_def]
);

(* --------------------------------------------------------------------------------------------- *)
val cellFill_memeq_thm = Q.store_thm ("cellFill_memeq_thm",
  `!wi:num pa:(48 word) (pm:(word48->word8)).
    (let sval =  (CellFill(wi, pa, pm)) (n2w(wi):(48 word)) in
	 sval =  v2w(read_mem32(pa ||  (n2w(wi):48 word) << 2, pm))
    )`,
   fs[CellFill_def, combinTheory.UPDATE_def]
);

val mem_uchg_tac = 
(     xrw []
    \\ Induct_on `n`  
    THENL[xrw []
         \\ lfs[EVAL ``COUNT_LIST 1``,  combinTheory.UPDATE_def],
	  xfs []
         \\ `SUC n = n + 1 ` by FULL_SIMP_TAC (arith_ss) []
	 \\ FULL_SIMP_TAC (bool_ss) []
	 \\ ASSUME_TAC( rich_listTheory.COUNT_LIST_ADD
			 |> Q.ISPECL[`(n:num) + 1`, `1:num`]
			 |> SIMP_RULE(srw_ss())[listTheory.MAP, EVAL ``COUNT_LIST  (1)``])

      \\ rfs []
      \\ xfs []
      \\ rfs[rich_listTheory.FOLDL_APPEND |> SIMP_RULE(srw_ss())[]]]
);

val linefill_memeq_thm = Q.store_thm ("linefill_memeq_t",
 `!(h:(actions # num # 48 word) list) i:(48 word) t:(48 word) (pm:(word48->word8)) (dc:(48 word -> CSET)) n state.
    (let (sl, _) =  LineFill(h, i, t, pm, dc, n) state in 
     let sn = w2n (word_log2 (state.DC.ccsidr.NumSets)) + 1 in
     let ln = (w2n state.DC.ctr.DminLine) in
     (n <= dimword(:15) ==>(!wi:num. wi <= n ==>
          let pa = (t << (sn + ln + 2)) !! (i << (ln + 2)) !! (n2w(wi):(48 word) << 2) in
	   (((THE (sl t)).value) (n2w(wi):48 word) = v2w(read_mem32(pa, pm)))
     )))`,

    xrw []
    \\ fs [LineFill_def,FOR_FOLDL, Abbr`pa`]
    \\ lrw[]
    \\ Induct_on `n`  
    THENL[xrw []
         \\ lfs[Abbr`sn`, Abbr`ln'`, EVAL ``COUNT_LIST 1``,  combinTheory.UPDATE_def, CellFill_def],

            ntac 2 strip_tac
	 \\ xrw[]
         \\ `n < 32768` by decide_tac
         \\ fs []
         \\ `SUC n = n + 1 ` by FULL_SIMP_TAC (arith_ss) []
         \\ FULL_SIMP_TAC (bool_ss) []
         \\ ASSUME_TAC( rich_listTheory.COUNT_LIST_ADD
    			 |> Q.ISPECL[`(n:num) + 1`, `1:num`]
    			 |> SIMP_RULE(srw_ss())[listTheory.MAP, EVAL ``COUNT_LIST  (1)``])
    
         \\ rfs[]
         \\ Cases_on `wi ≤ n`
         THENL[`wi < dimword(:15)` by (fs[] THEN REV_FULL_SIMP_TAC (arith_ss) [])
               \\ xfs[rich_listTheory.FOLDL_APPEND |> SIMP_RULE(srw_ss())[]]
               \\ abr_tac listSyntax.is_foldl
               \\ xfs[combinTheory.UPDATE_def]
	       \\ (CASE_TAC  THEN REV_FULL_SIMP_TAC (arith_ss) []),
	       
	          xfs [combinTheory.UPDATE_def]
	       \\ `(wi = n + 1)` by decide_tac
	       \\ xfs [rich_listTheory.FOLDL_APPEND |> SIMP_RULE(srw_ss())[], CellFill_def, combinTheory.UPDATE_def]
	       \\ abr_suc_tac ``sn``
	       \\ (fn (asl,g) => let val a = (find_term is_fst g) in  
                            (SUBGOAL_THEN ``^a = pm`` (fn thm => ASSUME_TAC thm)) (asl, g) end)
	       \\ mem_uchg_tac
	       \\ fs[]
	      ]
	 ]
);

(* --------------------------------------------------------------------------------------------- *)
val neg_word_msb = Q.prove(
  `!w. (w >= 0w) ==> ~(word_msb w)`,
    lrw[]
 \\ assume_tac (SPEC``w: 'a word``(GSYM word_msb_neg))
 \\ undisch_all_tac
 \\ blastLib.BBLAST_PROVE_TAC
);

val wIdx_extract_thm = Q.store_thm("wIdx_extract_thm",
 `! (pa:word48) (state:dharma8_state).
  let wi = wIdx(pa) state in 
  (wi) = (((w2n (state.DC.ctr.DminLine) + 1) >< (2 :num)) (pa:word48) :(48 word))`,
  
  lrw[wIdx_def]
  \\ ASSUME_TAC(word_extract_v2w
      |> Thm.INST_TYPE [Type.alpha |-> ``:48``, Type.beta  |-> ``:48``]
      |> Q.SPECL[`(w2n (state.DC.ctr.DminLine) + 1)`,`2n`,`w2v(pa:word48)`])
  \\ fs[v2w_w2v, word_bits_v2w]
  \\ blastLib.BBLAST_TAC);


val si_extract_thm = Q.store_thm("si_extract_thm",
 `!(va:word64) (pa:word48) (state:dharma8_state).
  let sid = si(va, pa) state in 
  let b = w2n (state.DC.ctr.DminLine) + 1 in
  let s = w2n (word_log2 (state.DC.ccsidr.NumSets)) + 1 in
  (sid) = ((s + b) >< (b + 1)) (pa:word48) :(48 word)`,

  xrw []
  \\ FULL_SIMP_TAC(bool_ss)[si_def]
  \\ ASSUME_TAC(word_extract_v2w
      |> Thm.INST_TYPE [Type.alpha |-> ``:48``, Type.beta  |-> ``:48``]
      |> Q.SPECL[`(s:num) + (b:num)`,`(b:num) + 1`,`w2v(pa:word48)`])
  \\ fs[v2w_w2v, word_bits_v2w]
  \\ unabbrev_all_tac
  \\ blastLib.BBLAST_TAC);

val word_log2_lt_adrSize = Q.store_thm("word_log2_lt_adrSize",
 `!v:(15 word).(v <> 0w) ==>  w2n(word_log2(v))  < 48`,
  xrw []
  \\ imp_res_tac LOG2_w2n_lt
  \\ fs [word_lt_n2w, word_log2_def]);


val tag_extract_thm = Q.store_thm("tag_extract_thm",
  `!(va:word64) (pa:word48) (state:dharma8_state).
  let tg = tag(va, pa) state in 
  let ps = LENGTH (w2v pa) in
  let bi = w2n (state.DC.ctr.DminLine) + 1 in
  let st = w2n (word_log2 (state.DC.ccsidr.NumSets)) + 1 in
  (* ((state.DC.ccsidr.NumSets + 1w) <> 0w) ==> *)
  ((tg) = ((ps - 1 >< (bi + st + 1)) (pa:word48) :(48 word)))`,

  xrw []
  \\ FULL_SIMP_TAC(bool_ss)[tag_def]
  \\ ASSUME_TAC(word_extract_v2w
      |> Thm.INST_TYPE [Type.alpha |-> ``:48``, Type.beta  |-> ``:48``]
      |> Q.SPECL[`ps - 1`,`((bi:num) + (st:num)) + 1`,`w2v(pa:word48)`])
  \\ fs [v2w_w2v, word_bits_v2w]
  \\ unabbrev_all_tac
  \\ blastLib.BBLAST_TAC);


val lineSpec_thm = Q.store_thm("lineSpec_thm",
  `!(va:word64) (pa:word48) (state:dharma8_state).
  let (i, t, wi) = lineSpec(va, pa) state in
  let ns = w2n (word_log2 (state.DC.ccsidr.NumSets)) + 1 in
  let nl = (w2n (state.DC.ctr.DminLine)) in
  invariant_cache ==>
  (* (¬word_msb state.DC.ctr.DminLine) ==> *)
  (pa = ((t ≪ (ns + nl + 2) ‖ i ≪ (nl + 2)) ‖ (n2w (wi):(48 word)) ≪ (2 :num)))`,

       lrw[]
    \\ PairedLambda.GEN_BETA_TAC
    \\ strip_tac
    \\ fs[lineSpec_def]
    \\ (qspecl_then [`pa`, `state`] assume_tac)wIdx_extract_thm
    \\ (qspecl_then [`va`, `pa`, `state`] assume_tac)si_extract_thm
    \\ (qspecl_then [`va`, `pa`, `state`] assume_tac)tag_extract_thm
    \\ rfs[LET_DEF]
    \\ (fn (asl, g) => let val trm = (snd o dest_eq) g
			  val  a::_::b::_ = find_terms wordsSyntax.is_w2n trm
		       in (Q.ABBREV_TAC`nl = ^a` \\ Q.ABBREV_TAC`ns = ^b`)(asl, g)
		       end)
    \\ assume_tac(EXTRACT_JOIN_LSL
        |> INST_TYPE [beta |-> ``:48``]
	|> Q.ISPECL [`47n`, `nl + (ns + 2n)`, `nl + (ns + 3n)`, `nl + 2n`, `(nl + (ns + 3n))`, `nl + 2n`, `pa:word48`]
	|> SIMP_RULE (srw_ss()++ARITH_ss)[])
    \\ `nl + (ns + 3) ≤ 47` by (all_tac
        \\ fs[invariant_cache_def]
	\\ qpat_assum `!i t wi ni nt s. P` (qspecl_then [`_`, `_`, `_`, `nl + 2`, `ns + 1`, `state`] ASSUME_TAC)
	\\ fs[])

    \\ `MIN 47 (MIN (nl + 49) 47) = 47` by fs[arithmeticTheory.MIN_DEF]
    \\ fs[]
    \\ assume_tac(EXTRACT_JOIN_LSL
        |> INST_TYPE [beta |-> ``:48``]
	|> Q.ISPECL [`47n`, `nl + 1n`, `nl + 2n`, `2n`, `nl + 2n`, `2n`, `pa:word48`]
	|> SIMP_RULE (srw_ss()++ARITH_ss)[])

    \\ assume_tac(SPECL[``(state :dharma8_state).DC.ctr.DminLine``](INST_TYPE[alpha |->``:4``]w2n_lt) 
       |> SIMP_RULE(srw_ss())[])
    \\ rfs[]

    \\ `2 ≤ nl + 1` by (all_tac
        \\ xfs[invariant_cache_def, Abbr`nl`]
	\\ qpat_assum `!i t wi ni nt s. P` (qspecl_then [`_`, `_`, `_`, `nl + 2`, `ns`, `state`] ASSUME_TAC)
	\\ assume_tac(WORD_GE |> Q.ISPECL[`state.DC.ctr.DminLine:word4`, `1w:word4`])
	\\ rfs[])

    \\ fs[invariant_cache_def]
    \\ qpat_assum`!pa'. 0xFFFFFFFFFFFCw && pa' = pa'` (qspecl_then[`pa`] assume_tac )
    \\ ntac 4 (WEAKEN_TAC is_forall)
    \\ undisch_all_tac
    \\ blastLib.BBLAST_PROVE_TAC
);

(* --------------------------------------------------------------------------------------------- *)
val fill_dcEQpm_thm = Q.store_thm("fill_dcEQpm_thm",
   `!(va:word64) (pa:word48) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state).
    (let (dc', pm') =  Fill(va, pa, pm, dc) state in
     let (i, t, wi) = lineSpec(va, pa) state in
     ((2 ** w2n state.DC.ctr.DminLine − 1) <= dimword(:15) ==>( invariant_cache ==>
      (wi <= (2 ** w2n state.DC.ctr.DminLine − 1)) ==> (CellRead(i, t, wi, dc') = v2w(read_mem32(pa, pm')))
     )))`,

   lrw []
   \\ ntac 3 (xfs[Fill_def, Once LET_DEF])
   \\ PairedLambda.GEN_BETA_TAC
   \\ REPEAT STRIP_TAC
   \\ xfs []
   \\ CASE_TAC
   THENL[
   xfs [LET_DEF]
   \\(fn (asl, g) => let val a::b::c::_ = (strip_pair o snd o dest_comb o fst o dest_eq) g 
		     in (Q.ABBREV_TAC`i = ^a`
			\\ Q.ABBREV_TAC`t = ^b`
			\\ Q.ABBREV_TAC`wi = ^c`)(asl, g)
		     end)
   \\ PairedLambda.GEN_BETA_TAC
   \\ fs [combinTheory.UPDATE_def]
   \\ simp[CellRead_def] 
   \\ ASSUME_TAC (linefill_memeq_thm
      |> Q.ISPECL[`((dc:(48 word -> CSET)) i).hist`,`i:(48 word)`,`t:(48 word)`,`(pm:(word48->word8))`,
                  `(dc:(48 word -> CSET))`, `2 ** w2n state.DC.ctr.DminLine − 1`, `state:dharma8_state`]
      |> SIMP_RULE(srw_ss())[LET_DEF] 
      |> PairedLambda.GEN_BETA_RULE)
   \\ rfs[]
   \\ PAT_ASSUM``!(wi:num). x`` (fn thm => ASSUME_TAC(SPECL[``wi:num``] thm))
   \\ THM_KEEP_TAC ``invariant_cache`` (fs[invariant_cache_def])
   \\ qpat_assum `!p:word48. P` (qspecl_then [`pa`] ASSUME_TAC)
   \\ ASSUME_TAC(lineSpec_thm
      |> Q.ISPECL[`va:word64`,`pa:word48`,`state:dharma8_state`]
      |> SIMP_RULE(srw_ss()) [LET_DEF]
      |> PairedLambda.GEN_BETA_RULE)
   \\ REABBREV_TAC
   \\ REV_FULL_SIMP_TAC (arith_ss) [],

   CONV_TAC (ONCE_DEPTH_CONV (REWRITE_CONV [LET_DEF]))
   \\ PairedLambda.GEN_BETA_TAC
   \\ fs [combinTheory.UPDATE_def] 
   \\ (fn (asl, g) => let val a::b::c::_ = (strip_pair o snd o dest_comb o fst o dest_eq) g 
		     in (Q.ABBREV_TAC`i = ^a`
			\\ Q.ABBREV_TAC`t = ^b`
			\\ Q.ABBREV_TAC`wi = ^c`)(asl, g)
		     end)
   \\ simp[CellRead_def]
   \\(fn (asl, g) => let val (cc, mm) = (dest_eq) g
			  val m = (snd o dest_pair o snd o dest_comb o fst o bitstringSyntax.dest_v2w ) mm
			  val c = (find_term is_abs) cc
  			  val h = (find_term is_snd) cc
		in (Q.ABBREV_TAC`pm' = ^m` 
		   \\ Q.ABBREV_TAC`dc' = ^c`
		   \\ Q.ABBREV_TAC`h' = ^h`) (asl, g) end)  
   \\ ASSUME_TAC (linefill_memeq_thm
      |> Q.ISPECL[`(h' :(actions # num # word48) list)`,`i:(48 word)`,`t:(48 word)`,`(pm':(word48->word8))`,
                  `(dc':(48 word -> CSET))`, `2 ** w2n state.DC.ctr.DminLine − 1`,`state:dharma8_state`]
      |> SIMP_RULE(srw_ss())[LET_DEF] 
      |> PairedLambda.GEN_BETA_RULE)
   \\ rfs []
   \\ PAT_ASSUM``!(wi:num). x`` (fn thm => ASSUME_TAC(SPECL[``wi:num``] thm))
   \\ THM_KEEP_TAC ``invariant_cache`` (fs[invariant_cache_def])
   \\ qpat_assum `!p:word48. P` (qspecl_then [`pa`] ASSUME_TAC)
   \\ ASSUME_TAC(lineSpec_thm
      |> Q.ISPECL[`va:word64`,`pa:word48`,`state:dharma8_state`]
      |> SIMP_RULE(srw_ss()) [LET_DEF]
      |> PairedLambda.GEN_BETA_RULE)
   \\ REABBREV_TAC
   \\ FULL_SIMP_TAC (arith_ss) []
]);

(* --------------------------------------------------------------------------------------------- *)
val shift_add_thm = Q.store_thm("shift_add_thm",
`!w1:(word48) w2 n m. ((w1 << (n + m)) !! (w2 << m)) = (((w1 << n) !! w2) << m)`,
fs[]);

val adr_neq_thm = Q.store_thm("adr_neq_thm",
 `!(a:word48) (b:word48) (c:word48) (d:word48) (n:num). 
   let bmM = ((0xffffffffffffw:word48) >>> n) in
   let bmL = ~((0xffffffffffffw:word48) >>> n << n) in
  ((n < 48)) ==>  
  ((a && bmM = a) /\ (b && bmM = b)) ==>
  ((c && bmL = c) /\ (d && bmL = d)) ==>
  ((a << n) <> (b << n)) ==>   
  (((a << n) !! c) <> ((b << n) !! d))`,

  ntac 4 strip_tac
  \\ ntac 48 (Induct_on `n`
   THENL[fs[] \\ blastLib.BBLAST_PROVE_TAC,  
	 fs[] \\ PAT_ASSUM ``a``(fn thm => all_tac)])
);

val writeback_mem_eq_thm = Q.store_thm ("writeback_mem_eq_thm",
  `!(pa:word48) (va:word64) (pm:(word48->word8)) (slval:SLVAL) (state:dharma8_state) i':(48 word) t':(48 word) (wi':num).
	    (let (i, t, wi) = lineSpec(va, pa) state in
             let pm' =  WriteBack(i', t', wi', pm, slval) state in 
	     let ns = w2n (word_log2 (state.DC.ccsidr.NumSets)) + 1 in 
	     let nl = (w2n state.DC.ctr.DminLine) in 
	     (((((t' << ns) !! i') << (nl + 2n)) <> ((t << ns) !! i) << (nl + 2n)) ==> 
	      (invariant_cache) ==> 
	      (v2w(read_mem32(pa, pm)):word32 = v2w(read_mem32(pa, pm')))	
	      )
	    )`,

        lrw[]
     \\ PairedLambda.GEN_BETA_TAC	      
     \\ (fn (asl, g) => let val  a::b::_ = find_terms wordsSyntax.is_w2n ((fst o dest_imp) g)
			    val  c::d::_ = find_terms is_fst ((fst o dest_imp) g)
		       in (Q.ABBREV_TAC`ns = (^a + 1n)` \\ Q.ABBREV_TAC`nl = ^b`
			\\ Q.ABBREV_TAC`t = ^c`  \\ Q.ABBREV_TAC`i = ^d`)(asl, g)        end)
     \\ abr_suc_tac ``ns``
     \\ xrw []
     \\ fs [WriteBack_def, combinTheory.UPDATE_def, read_mem32_def]

     \\ ASSUME_TAC(lineSpec_thm
 	     |> Q.ISPECL[`va:word64`,`pa:word48`,`state:dharma8_state`]
	     |> SIMP_RULE(srw_ss()) [LET_DEF]
	     |> PairedLambda.GEN_BETA_RULE)
	   \\ REABBREV_TAC
     \\ rfs[]
     \\ Q.ABBREV_TAC`wi = (SND (SND (lineSpec (va,pa) state)))`
     \\ THM_KEEP_TAC ``invariant_cache`` (fs[invariant_cache_def])
     \\ qpat_assum `!i t wi ni nt s. P` (qspecl_then [`i`, `t`, `wi`, `nl + 2n`, `ns`, `state`] ASSUME_TAC)
     \\ qpat_assum `!p:word48. a=b` (qspecl_then [`w2w(i ≪ (nl+2) ‖ t ≪ (nl+(ns+2)) ‖ n2w wi ≪ 2)`] ASSUME_TAC)
     \\ ntac 3 (WEAKEN_TAC is_forall)
     \\ fs[invariant_cache_def]
     \\ qpat_assum `!i t wi ni nt s. P` (qspecl_then [`i'`, `t'`, `wi'`, `nl + 2n`, `ns`, `state`] ASSUME_TAC)
     \\ qpat_assum `!p:word48. a=b` (qspecl_then [`w2w(i' ≪ (nl+2) ‖ t' ≪ (nl+(ns+2)) ‖ n2w wi' ≪ 2)`] ASSUME_TAC)
     \\ ntac 3 (WEAKEN_TAC is_forall)
   
     \\ (qspecl_then [`(t << ns !! i )`, `(t' << ns !! i' )`, `n2w wi << 2`, `n2w wi' << 2`, `(nl + 2)`] ASSUME_TAC) adr_neq_thm
     \\ fs[LET_DEF]
     \\ rfs[]
     \\ Q.ABBREV_TAC`pa' = (i' ≪ (nl + 2) ‖ t' ≪ (nl + (ns + 2)) ‖ n2w wi' ≪ 2)`
     \\ Q.ABBREV_TAC`pa = (i ≪ (nl + 2) ‖ t ≪ (nl + (ns + 2)) ‖ n2w wi ≪ 2)`
     \\ REPEAT ((fn (asl, g) => 
                let val (t,_,_) = (dest_cond o find_term is_cond o snd o dest_eq) g in
	        `~^t` by  (ntac 2 (UNDISCH_MATCH_TAC ``0xFFFFFFFFFFFCw && x = x``)
			   \\ (UNDISCH_MATCH_TAC ``x <> y``) 
			   \\ blastLib.BBLAST_PROVE_TAC ) end (asl, g))
	        \\ fs [])
);

(* --------------------------------------------------------------------------------------------- *)
val lineSpec_eq_thm = Q.store_thm("lineSpec_eq_thm",
 `!s s' pa va.
  invariant_cache ==>
  (lineSpec(va, pa) s = lineSpec(va, pa) s')`,

  lrw[]
  \\ fs[invariant_cache_def]
  \\ qpat_assum `!s:dharma8_state a'. P` (qspecl_then [`s`, `s'`] ASSUME_TAC)
  \\ REPEAT (WEAKEN_TAC is_forall)
  \\ fs[lineSpec_def, si_def, tag_def, wIdx_def]
);


val writebackline_mem_eq_thm = Q.store_thm("writebackline_mem_eq_thm",
 `! i':(48 word) t':(48 word)  (pm:(word48->word8)) (dc:(48 word -> CSET)) (n:num) (va:word64) (pa:word48) (state:dharma8_state) .
	    (let (i, t, wi) = lineSpec(va, pa) state in
	     let (dc', pm') =  WriteBackLine(i', t', pm, dc, n) state in
	     let ns = w2n (word_log2 (state.DC.ccsidr.NumSets)) + 1 in
	     let nl = (w2n state.DC.ctr.DminLine) in 
	      (((((t' << ns) !! i') << (nl + 2n)) <> ((t << ns) !! i) << (nl + 2n)) ==>
	       (n <= dimword(:15)) ==> 
	       (invariant_cache) ==> 
	       (v2w(read_mem32(pa, pm)):word32 = v2w(read_mem32(pa, pm')))
	      )
	    )`,



     fs [WriteBackLine_def, combinTheory.UPDATE_def, FOR_FOLDL]
    \\ rpt strip_tac
    \\ (Induct_on`n` \\ PairedLambda.GEN_BETA_TAC \\ lrw [])
    THENL[lfs[EVAL ``COUNT_LIST 1``]
         \\ assume_tac(writeback_mem_eq_thm
             |> spec_let_elim[`pa`,`va`,`pm`, `THE (((dc:(48 word -> CSET)) i').sl t')`, `state`, `i':word48`, `t'`, `0`] 
             |> SIMP_RULE(srw_ss()) [WriteBack_def, LET_DEF, combinTheory.UPDATE_def])
         \\ rfs[],
        
          UNDISCH_MATCH_TAC``(\(a,b, c). (x)) d``
         \\ PairedLambda.GEN_BETA_TAC
         \\ strip_tac
         \\ `n < 32768` by decide_tac
         \\ fs[]
         \\`SUC n = n + 1 ` by FULL_SIMP_TAC (arith_ss) []
         \\ REV_FULL_SIMP_TAC (bool_ss) []
         \\ ASSUME_TAC( rich_listTheory.COUNT_LIST_ADD
         			 |> Q.ISPECL[`(n:num) + 1`, `1:num`]
         			 |> SIMP_RULE(srw_ss())[listTheory.MAP, EVAL ``COUNT_LIST  (1)``])
         
         \\ rfs[rich_listTheory.FOLDL_APPEND |> SIMP_RULE(srw_ss())[]]
         \\ abr_tac listSyntax.is_foldl
         \\ assume_tac (writeback_mem_eq_thm |> spec_let_elim[`pa`, `va`, 
           `FST (SND (SND (SND (abr :SLVAL #(word48 -> SLVAL option) #(word48 -> CSET) #(word48 -> word8) # dharma8_state))))`, 
           `FST (abr :SLVAL #(word48 -> SLVAL option) #(word48 -> CSET) #(word48 -> word8) # dharma8_state)`, 
           `(SND (SND (SND (SND (abr :SLVAL #(word48 -> SLVAL option) #(word48 -> CSET) #(word48 -> word8) # dharma8_state)))))`,
           `i'`,`t'`,`n+1`]
            |> SIMP_RULE(srw_ss()) [WriteBack_def, LET_DEF, combinTheory.UPDATE_def])

         \\ THM_KEEP_TAC ``invariant_cache`` (fs[invariant_cache_def])
         \\ qpat_assum `!s:dharma8_state s'. P` (qspecl_then [`state`, 
             `(SND (SND (SND (SND (abr :SLVAL #(word48 -> SLVAL option) #(word48 -> CSET) #(word48 -> word8) # dharma8_state)))))`] ASSUME_TAC)
         \\ (qspecl_then [`state`, `(SND (SND (SND (SND (abr :SLVAL #(word48 -> SLVAL option) #(word48 -> CSET) #(word48 -> word8) # dharma8_state)))))`, `pa`, `va`] ASSUME_TAC) lineSpec_eq_thm
         \\ fs[]
	 \\ metis_tac[] ]
);  


(* val writebackline_mem_eq_thm = Q.store_thm("writebackline_mem_eq_thm", *)
(*     `! i':(48 word) t':(48 word) (pa:word48) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state) (n:num). *)
(* 	    (let (i, t, wi) = lineSpec(va, pa) state in *)
(* 	     let (dc', pm') =  WriteBackLine(i', t', pm, dc, n) state in *)
(* 	     let ns = w2n (word_log2 (state.DC.ccsidr.NumSets + 1w)) in *)
(* 	     let nl = (w2n state.DC.ctr.DminLine) in  *)
(* 	      (((((t' << ns) !! i') << (nl + 2n)) <> ((t << ns) !! i) << (nl + 2n)) ==> *)
(* 	       (n < dimword(:15)) ==>  *)
(* 	       (invariant_cache) ==>  *)
(* 	       (v2w(read_mem32(pa, pm)):word32 = v2w(read_mem32(pa, pm'))) *)
(* 	      ) *)
(* 	    )`, *)

(*      fs [WriteBackLine_def, combinTheory.UPDATE_def, FOR_FOLDL] *)
(*     \\ ntac 6 strip_tac *)
(*     \\ (Induct \\ PairedLambda.GEN_BETA_TAC \\ lrw []) *)
(*     THENL[lfs[EVAL ``COUNT_LIST 1``] *)
(*          \\ (qspecl_then [`pa`,`va`,`pm`, `THE ((dc i').sl t')`, `state`, `i'`, `t'`, `0`] assume_tac) writeback_mem_eq_thm *)
(*          \\ fs[LET_DEF] *)
(*          \\ UNDISCH_MATCH_TAC``(\(a,b, c). (x)) d`` *)
(*          \\ PairedLambda.GEN_BETA_TAC *)
(*          \\ lrw[], *)
        
(*           UNDISCH_MATCH_TAC``(\(a,b, c). (x)) d`` *)
(*          \\ PairedLambda.GEN_BETA_TAC *)
(*          \\ strip_tac *)
(*          \\ `n < 32768` by decide_tac *)
(*          \\ fs[] *)
(*          \\`SUC n = n + 1 ` by FULL_SIMP_TAC (arith_ss) [] *)
(*          \\ REV_FULL_SIMP_TAC (bool_ss) [] *)
(*          \\ ASSUME_TAC( rich_listTheory.COUNT_LIST_ADD *)
(*          			 |> Q.ISPECL[`(n:num) + 1`, `1:num`] *)
(*          			 |> SIMP_RULE(srw_ss())[listTheory.MAP, EVAL ``COUNT_LIST  (1)``]) *)
         
(*          \\ rfs[rich_listTheory.FOLDL_APPEND |> SIMP_RULE(srw_ss())[]] *)
(*          \\ abr_tac listSyntax.is_foldl *)
(*          \\ assume_tac (writeback_mem_eq_thm |> spec_let_elim[`pa`, `va`,  *)
(*            `FST (SND (SND (SND (abr :SLVAL #(word48 -> SLVAL option) #(word48 -> CSET) #(word48 -> word8) # dharma8_state))))`,  *)
(*            `FST (abr :SLVAL #(word48 -> SLVAL option) #(word48 -> CSET) #(word48 -> word8) # dharma8_state)`,  *)
(*            `(SND (SND (SND (SND (abr :SLVAL #(word48 -> SLVAL option) #(word48 -> CSET) #(word48 -> word8) # dharma8_state)))))`, *)
(*            `i'`,`t'`,`n+1`]) *)

(*          \\ THM_KEEP_TAC ``invariant_cache`` (fs[invariant_cache_def]) *)
(*          \\ qpat_assum `!s:dharma8_state s'. P` (qspecl_then [`state`,  *)
(*              `(SND (SND (SND (SND (abr :SLVAL #(word48 -> SLVAL option) #(word48 -> CSET) #(word48 -> word8) # dharma8_state)))))`] ASSUME_TAC) *)
(*          \\ (qspecl_then [`state`, `(SND (SND (SND (SND (abr :SLVAL #(word48 -> SLVAL option) #(word48 -> CSET) #(word48 -> word8) # dharma8_state)))))`, `pa`, `va`] ASSUME_TAC) lineSpec_eq_thm *)
(*          \\ fs[] *)
(* 	 \\ metis_tac[] ] *)
(* );   *)



(* --------------------------------------------------------------------------------------------- *)
val adr_segEq_thm = Q.prove(
 `!(a:word48) (b:word48) (c:word48) (d:word48) (n:num) (m:num). 
   let bmM = ((0xffffffffffffw:word48) >>> (n + m)) in
   let bmL = (((0xffffffffffffw:word48) << (48 - (n + m))) >>> (48 - n)) in
  ((n < 48) /\ (m < (48 - n))) ==>  
  ((a && bmM = a) /\ (b && bmL = b)) ==>
  ((c && bmM = c) /\ (d && bmL = d)) ==>
  ((((a << (n+m)) !! (b << m) ) =  ((c << (n+m)) !! (d << m))) ==>  ((a = c) /\ (b = d)))`,  cheat);

  ntac 4 strip_tac
  \\ ntac 48 (Induct_on `n`
  THENL[ntac 48(Induct_on `m`
  THENL[fs[] \\ blastLib.BBLAST_PROVE_TAC,  
        fs[] \\ PAT_ASSUM ``a``(fn thm => all_tac)]),
  fs[] \\ PAT_ASSUM ``a``(fn thm => all_tac)])

);

val adr_neq4_thm = Q.prove(
 `!(a:word48) (b:word48) (c:word48) (d:word48) (n:num) (m:num). 
   let bmM = ((0xffffffffffffw:word48) >>> (n + m)) in
   let bmL = (((0xffffffffffffw:word48) << (48 - (n + m))) >>> (48 - n)) in
  ((n < 48) /\ (m < (48 - n))) ==>  
  ((a && bmM = a) /\ (b && bmL = b)) ==>
  ((c && bmM = c) /\ (d && bmL = d)) ==>   
  ((a <> c) ==> (((a << (n+m)) !! (b << m) ) <>  ((c << (n+m)) !! (d << m)))) /\
  ((d <> b) ==> (((a << (n+m)) !! (b << m) ) <>  ((c << (n+m)) !! (d << m))))`,

 ntac 4 strip_tac
  \\ ntac 48 (FIRST[Cases_on`n`, Cases_on`n'`]
  >- (ntac 48(Induct_on `m`
  THENL[fs[] \\ blastLib.BBLAST_PROVE_TAC, fs[] \\ PAT_ASSUM ``a``(fn thm => all_tac)])) 
  \\ fs[])
);

val word_shift_eq = Q.prove(
 `!w:word48 v m. (w = v) ==> ((w << m) = (v << m))`,
blastLib.BBLAST_PROVE_TAC);


local
  val th1 = `x <> t'` by (all_tac  
    \\ CCONTR_TAC
    \\ fs[invariant_cache_def, Hit_def]
    \\ qpat_assum `∀h i t dc x. P` (qspecl_then [`((dc:word48->CSET) (i:word48)).hist`, `i`, `t`, `dc`, `t'`] assume_tac)
    \\ UNDISCH_MATCH_TAC ``¬(λ(li,t,wi). IS_SOME (b)) (a)``
    \\ PairedLambda.GEN_BETA_TAC
    \\ rwsimp[])

  val subgoal_tac1 =
       (TAKE_DOWN_TAC ``a ==> b``
    \\ FIRST_ASSUM (fn thm => let val trm = (fst o dest_imp o concl) thm in `^trm`by all_tac end)
    >- (assume_tac(adr_neq4_thm |> spec_let_elim [`x`, `i`, `t'`, `i'`, `ns`, `(nl + 2)`])
       \\ THM_KEEP_TAC``invariant_cache`` (fs[invariant_cache_def])
       \\ qpat_assum `!i t wi ni nt s. P` (qspecl_then [`i'`, `t'`, `_`, `nl + 2n`, `ns`, `state`] ASSUME_TAC)
       \\ xfs[invariant_cache_def]
       \\ qpat_assum `!i t wi ni nt s. P` (qspecl_then [`i`, `x`, `_`, `nl + 2n`, `ns`, `state`] ASSUME_TAC)
       \\ rfs[])
    \\ fs[])

in
 val fill_pm'EQpm_diffIn_thm = Q.store_thm("fill_pm'EQpm_diffIn_thm",
  `!(va:word64) (pa:word48) (pm:(word48->word8)) (dc:(48 word -> CSET)) (va':word64) (pa':word48) (state:dharma8_state).
    (let (dc', pm') =  Fill(va, pa, pm, dc) state in    
     ((invariant_cache ==> ( w2n (word_log2 (state.DC.ccsidr.NumSets)) + 1 < 48) ==>
      ~Hit(va', pa', dc) state ==>
      (v2w(read_mem32(pa', pm')):word32 =v2w(read_mem32(pa', pm)))
     )))`,

    lrw []
    \\ fs_lambda_elim[Fill_def]
    \\ rpt strip_tac
    \\ CASE_TAC
    THENL[fs_lambda_elim[LET_DEF]
    \\ fs[],
   
    CONV_TAC (ONCE_DEPTH_CONV (REWRITE_CONV [LET_DEF]))
    \\ fs_lambda_elim [combinTheory.UPDATE_def] 
    \\ Q.ABBREV_TAC`i = FST (lineSpec (va,pa) state)`
    \\ THM_SPECL_GOAL "WriteBackLine" writebackline_mem_eq_thm [``va':word64``, ``pa':word48``, ``state:dharma8_state``]
    \\ abr_tac_goal wordsSyntax.is_w2n "nl" NONE
    \\ undisch_all_tac
    \\ abr_lineSpec_tac_dubl
    \\ rpt strip_tac
    \\ line_size_lt_dimword15 ``nl:num``
    \\ set_size_lt_48
    \\ Q.ABBREV_TAC`ns = w2n (word_log2 state.DC.ccsidr.NumSets) + 1`
    \\ Cases_on`i <> i'`
    >- subgoal_tac1
    \\ (th1 \\ subgoal_tac1)])
end;

(* --------------------------------------------------------------------------------------------- *)
val cacheRead_miss_thm = Q.store_thm("cacheRead_miss_thm",
  `!(va:word64) (pa:word48) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state).
  let (dc', pm', vlc) = CacheRead (va, pa, pm, dc) state in
  let (i, t, wi) = lineSpec(va, pa) state  in
  let vlm = v2w(read_mem32(pa, pm)):word32 in
      invariant_cache ==>
      (~(Hit(va, pa, dc) state) ==> (vlm = v2w(vlc):word32))`,
  
    lrw []
    \\ xfs[CacheRead_def]
    \\ (CASE_TAC \\ CONV_TAC (ONCE_DEPTH_CONV PairedLambda.GEN_BETA_CONV))
    \\ PairedLambda.GEN_BETA_TAC
    \\ REPEAT STRIP_TAC
    \\ fs[Once LET_DEF]
    \\ PairedLambda.GEN_BETA_TAC
    \\ (fn (asl, g) => let val trm = ((find_term bitstringSyntax.is_w2v) o snd o dest_eq) g
			  val  b::a::_ = (find_terms is_fst) trm
			  val  c  = (fst o wordsSyntax.dest_n2w o find_term wordsSyntax.is_n2w) trm
		      in (Q.ABBREV_TAC`i = ^a`
			 \\ Q.ABBREV_TAC`t = ^b`
			 \\ Q.ABBREV_TAC`wi = ^c` )(asl, g)
		      end)

    \\ ASSUME_TAC(fill_dcEQpm_thm
       |> Q.ISPECL[`va:word64`,`pa:word48`,`(pm:(word48->word8))`,`(dc:(48 word->CSET))`,`(state:dharma8_state)`] 
       |> SIMP_RULE (srw_ss()) [LET_DEF]
       |> PairedLambda.GEN_BETA_RULE)
    \\ rfs[combinTheory.UPDATE_def]
    \\ THM_KEEP_TAC ``invariant_cache`` (fs[invariant_cache_def])
    \\ qpat_assum `!i t w n m state. P` (qspecl_then [`i`, `t`, `wi`, `nl + 2`, `ns`, `state`] assume_tac)
    \\ ntac 4 (WEAKEN_TAC is_forall)


    \\ assume_tac(w2n_lt |> INST_TYPE[alpha|->``:4``] |> Q.ISPECL[`state.DC.ctr.DminLine`] |> SIMP_RULE(srw_ss())[])
    \\ `w2n state.DC.ctr.DminLine <= 15` by decide_tac
    \\ SUBGOAL_THEN ``!a b. a <= b ==> 2**a <= 2**b`` (fn thm => ASSUME_TAC thm)
    >-(FULL_SIMP_TAC (arith_ss) [])
    \\ qpat_assum `!a b. P` (qspecl_then [`w2n state.DC.ctr.DminLine`, `15n`] assume_tac)
    \\ (qspecl_then [`2 ** w2n state.DC.ctr.DminLine`, `2 ** 15`] assume_tac) arithmeticTheory.LE_LT1
    \\ FULL_SIMP_TAC (arith_ss)[CellRead_def]
    \\ assume_tac(fill_pm'EQpm_diffIn_thm
       |> Q.SPECL [`va`,`pa`,`pm`,`dc`,`va`, `pa`, `(state:dharma8_state)`]
       |> SIMP_RULE (srw_ss())[LET_DEF]
       |> PairedLambda.GEN_BETA_RULE)
   \\ SUBGOAL_THEN ``w2n (word_log2 (state.DC.ccsidr.NumSets)) + 1 < 48`` (fn thm => assume_tac thm)
   \\ fs[word_log2_def]
   \\ (qspecl_then [`state.DC.ccsidr.NumSets`] assume_tac) (INST_TYPE [alpha |-> ``:15``]LOG2_w2n_lt)
   (*\\  `(state.DC.ccsidr.NumSets ≥ 0w) ==> (state.DC.ccsidr.NumSets ≠ 0w)` by blastLib.BBLAST_TAC *)
   \\ res_tac
   \\ fs[]
);

val CacheRead_dcEQpm_NotDirty_thm = Q.store_thm("CacheRead_dcEQpm_NotDirty_thm",
 `!(va:word64) (pa:word48) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state).
  let (_,_, vlc) = CacheRead(va, pa, pm, dc) state in
  let vlm = read_mem32(pa, pm) in 
  (invariant_cache) ==>
  (~lDirty(va, pa, dc) state) ==>  
  (v2w(vlc):word32 = v2w(vlm):word32)`,

    fs_lambda_elim[CacheRead_def, Touch_def, lDirty_def]
    \\ lrw[]
    >- ( abr_lineSpec_tac_sgl
	\\ PAIR_SPLIT_TAC
	\\ THM_KEEP_TAC ``invariant_cache`` (fs[invariant_cache_def])
	\\ qpat_assum `∀i t wi dc' pm sn ln. P` (qspecl_then[`i'`, `t'`, `wi'`, `dc`, `pm`, 
            `w2n (word_log2 state.DC.ccsidr.NumSets) + 1`, `w2n state.DC.ctr.DminLine`]
           assume_tac)
	\\ THM_SPECL_ASSM "lineSpec" lineSpec_thm [``state:dharma8_state``]
	\\ rfs[CellRead_def]
       )
    \\ THM_SPECL_GOAL "Fill" cacheRead_miss_thm [``state:dharma8_state``]
    \\ fs_lambda_elim[CacheRead_def]
    \\ rfs[]
);

(* --------------------------------------------------------------------------------------------- *)
val cacheRead_hit_thm = Q.store_thm("cacheRead_hit_thm",
  `!(va:word64) (pa:word48) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state).
  let (dc', pm', vlc) = CacheRead (va, pa, pm, dc) state in
  let (i, t, wi) = lineSpec(va, pa) state in
  let vlc' = CellRead(i, t, wi, dc) in
      ((Hit(va, pa, dc) state) ==> (vlc' = v2w(vlc):word32))`,
  
   lrw []
   \\ xfs[CacheRead_def, CellRead_def]
   \\ (CASE_TAC \\ CONV_TAC (ONCE_DEPTH_CONV PairedLambda.GEN_BETA_CONV))
   \\ ntac 2 (fs[Once LET_DEF])
   \\ PairedLambda.GEN_BETA_TAC
   \\ fs[combinTheory.UPDATE_def, Touch_def]
);

(* --------------------------------------------------------------------------------------------- *)
val cacheWrite_setCell_thm = Q.store_thm("cacheWrite_setCell_thm",
 `!(va:word64) (pa:word48) (data:wrTyp) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state).
  let (dc', pm')= CacheWrite (va, pa, data, pm, dc) state in 
  let (i, t, wi) = lineSpec(va, pa) state  in
      ((THE ((dc' i).sl t)).dirty = data.flag) /\ 
      ((THE ((dc' i).sl t)).value (n2w wi) = data.value)`,

      lrw[]
   \\ fs[CacheWrite_def]
   \\ PairedLambda.GEN_BETA_TAC
   \\ rw[Touch_def, combinTheory.UPDATE_def]  
);

(* --------------------------------------------------------------------------------------------- *)
val linefill_hit_thm = Q.store_thm ("linefill_hit_t",
   `!(h:(actions # num # 48 word) list) i:(48 word) t:(48 word) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state) (n:num).
    let (sl, _) =  LineFill(h, i, t, pm, dc, n) state in 
     let sn = w2n (word_log2 (state.DC.ccsidr.NumSets + 1w)) in
     let ln = (w2n state.DC.ctr.DminLine) in
     (!wi:num.
       let pa = (t << (sn + ln + 2)) !! (i << (ln + 2)) !! (n2w(wi):(48 word) << 2) in 
	   (IS_SOME(sl t))
     )`,

    xrw []
    \\ fs [LineFill_def,FOR_FOLDL, Abbr`pa`]
    \\ lrw[]
    \\ Induct_on `n`  
    THENL[lfs[EVAL ``COUNT_LIST 1``,  combinTheory.UPDATE_def],
          xfs [combinTheory.UPDATE_def]]
				     
);

val fill_hit_thm = Q.store_thm("fill_hit_thm",
  `!(va:word64) (pa:word48) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state).
    (let (dc', pm') =  Fill(va, pa, pm, dc) state in
     let (i, t, wi) = lineSpec(va, pa) state in    
      (* (IS_SOME((dc' i).sl t)) *)
      Hit(va, pa, dc') state
    )`,

   lrw []
   \\ NTAC 3 (xfs[Fill_def, Hit_def, Once LET_DEF])
   \\ PairedLambda.GEN_BETA_TAC
   \\ CASE_TAC

   THENL[ (fn (asl, g) => let val a::b::_ = find_terms is_fst g in
       (Q.ABBREV_TAC`t = ^a` \\ Q.ABBREV_TAC`i = ^b`)(asl, g) end)
   \\ fs_lambda_elim [LET_DEF]
   \\ fs[combinTheory.UPDATE_def]
   \\ assume_tac(linefill_hit_thm |> spec_let_elim [`((dc:(48 word -> CSET)) i).hist`, `i`, `t`, `pm`, `dc`, `state`, `2 ** w2n state.DC.ctr.DminLine − 1`])
   \\ rfs[],

      (fn (asl, g) => let val a::b::_ = find_terms is_fst g in
       (Q.ABBREV_TAC`t = ^a` \\ Q.ABBREV_TAC`i = ^b`)(asl, g) end)
   \\  CONV_TAC (ONCE_DEPTH_CONV (REWRITE_CONV [LET_DEF]))
   \\ PairedLambda.GEN_BETA_TAC
   \\ fs [combinTheory.UPDATE_def]
   \\ (fn (asl, g) => let val b = find_term is_abs  g   val a = find_term is_snd g in
       (Q.ABBREV_TAC`dc' = ^b` \\ Q.ABBREV_TAC`hist' = ^a`) (asl,g) end)
   \\ (fn (asl, g) => let val c = find_term is_writeBackLine  g in (Q.ABBREV_TAC`pm' = SND (^c state)`) (asl,g) end)
   \\ assume_tac(linefill_hit_thm 
       |> spec_let_elim [`hist'`, `i`, `t`, `pm'`, `dc'`, `state`, `2 ** w2n state.DC.ctr.DminLine − 1`])
   \\ rfs[]]
);



val cacheRead_paHitdc'_thm = Q.store_thm("cacheRead_paHitdc'_thm",
  `!(va:word64) (pa:word48) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state).
  let (dc', pm', _)= CacheRead(va, pa, pm, dc) state in 
        (Hit(va, pa, dc') state)`,

       lrw[]
    \\ fs[CacheRead_def]
    \\ PairedLambda.GEN_BETA_TAC
    \\ rw[Touch_def, combinTheory.UPDATE_def]  
    >- (fs[Hit_def] \\ schneiderUtils.UNDISCH_ALL_TAC \\ PairedLambda.GEN_BETA_TAC \\ fs[])

    \\ (fs[Hit_def] \\ schneiderUtils.UNDISCH_ALL_TAC \\ PairedLambda.GEN_BETA_TAC \\ fs[])
    \\ lrw[]
    \\ (fn (asl, g) => let val a::b::_ = find_terms is_fst g in (Q.ABBREV_TAC`t = ^a` \\ Q.ABBREV_TAC`i = ^b`)(asl, g) end)
    \\ assume_tac (fill_hit_thm |> spec_let_elim[`va`, `pa`, `pm`, `dc`, `state`] 
          |> SIMP_RULE(srw_ss())[LET_DEF, Hit_def] |> PairedLambda.GEN_BETA_RULE)
    \\ rfs[] 
);

val cacheWrite_paHitdc'_thm = Q.store_thm("cacheWrite_paHitdc'_thm",
  `!(va:word64) (pa:word48) (data:wrTyp) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state).
  let (dc', pm')= CacheWrite(va, pa, data, pm, dc) state in 
        (Hit(va, pa, dc') state)`,
       lrw[]
    \\ fs[CacheWrite_def]
    \\ PairedLambda.GEN_BETA_TAC
    \\ rw[Touch_def, combinTheory.UPDATE_def]  
    \\ EVERY[fs[Hit_def] \\ PairedLambda.GEN_BETA_TAC \\ PAIR_SPLIT_TAC \\ fs[]]);

(* --------------------------------------------------------------------------------------------- *)
val cacheWrite_paNOTCHGpm_thm = Q.store_thm("cacheWrite_paNOTCHGpm_thm",
 `!(va:word64) (pa:word48) (data:wrTyp) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state).
  let (dc', pm')= CacheWrite (va, pa, data, pm, dc) state in 
       invariant_cache ==>
       (v2w(read_mem32(pa, pm)):word32 = v2w(read_mem32(pa, pm')))`,

      lrw[]
    \\ fs[CacheWrite_def]
    \\ PairedLambda.GEN_BETA_TAC
    \\ rw[Touch_def, combinTheory.UPDATE_def]  
    \\ SUBGOAL_THEN ``w2n (word_log2 (state.DC.ccsidr.NumSets)) + 1 < 48`` (fn thm => assume_tac thm)
    >- (xfs[word_log2_def, invariant_cache_def]
    \\ qpat_assum `∀i t wi ni nt state. P` (qspecl_then[`_`, `_`, `_`, `_`, `_`, `state`] assume_tac)
    \\ rfs[]
    (* \\ `(state.DC.ccsidr.NumSets ≥ 0w) ==> (state.DC.ccsidr.NumSets + 1w ≠ 0w)` by blastLib.BBLAST_TAC *)
    \\ res_tac
    \\ imp_res_tac (INST_TYPE [alpha |-> ``:15``]LOG2_w2n_lt)
    \\ fs[])
    \\ imp_res_tac (fill_pm'EQpm_diffIn_thm |> SIMP_RULE(srw_ss())[LET_DEF] |> PairedLambda.GEN_BETA_RULE)
    \\ qpat_assum `!x .P` (qspecl_then [`va`,`pm`, `pa`] assume_tac)
    \\ fs[]);

val cacheWrite_read_thm = Q.store_thm("cacheWrite_read_thm", 
  `!(va:word64) (pa:word48) (data:wrTyp) (pm:(word48->word8)) (dc:(48 word -> CSET)) (state:dharma8_state).
  let (dc', pm')= CacheWrite(va, pa, data, pm, dc) state in 
  let (a, b, vl)= CacheRead (va, pa, pm', dc') state in
       ((v2w vl:word32) = data.value)`,

       lrw[]
    \\ PairedLambda.GEN_BETA_TAC
    \\ fs[CacheRead_def]
    \\ PairedLambda.GEN_BETA_TAC
    \\ rw[Touch_def, combinTheory.UPDATE_def]  
    >- rfs[ (cacheWrite_setCell_thm 
          |> Q.ISPECL[`va:word64`, `pa:word48`, `data:wrTyp`, `pm:(word48->word8)`, `dc:(word48->CSET)`, `state:dharma8_state`]
	  |> SIMP_RULE (srw_ss()) [LET_DEF] |> PairedLambda.GEN_BETA_RULE)]
    \\ fs[(cacheWrite_paHitdc'_thm 
    |> Q.ISPECL[`va:word64`, `pa:word48`, `data:wrTyp`, `pm:(word48->word8)`, `dc:(48 word -> CSET)`, `state:dharma8_state`]
    |> SIMP_RULE(srw_ss()) [LET_DEF] |> PairedLambda.GEN_BETA_RULE)]
);

val cache_write_read_WB_thm = Q.store_thm("cache_write_read_WB_thm", 
  `!(va:word64) (pa:word48) data:bitstring  (mc:MEM_CONFIG) (pm:(word48->word8)) (dc:(48 word -> CSET)) (dirty:bool) state. 
   let (_,pm',dc') = write_cache(0w:word32, va, pa, data, mc, pm ,dc, dirty) state in 
   let (_, _, vl)  = read_cache(0w:word32, va, pa, pm', dc') state in 
     (LENGTH data = 32) ==>
     (v2w(data):word32  = v2w(vl))`,


    lrw[]
    \\ PairedLambda.GEN_BETA_TAC
    \\ fs[read_cache_def, write_cache_def]
    \\ PairedLambda.GEN_BETA_TAC
    \\ rw[combinTheory.UPDATE_def]  
    \\ (NTAC 4 (xfs [Once state_transformerTheory.FOR_def, state_transformerTheory.BIND_DEF]))
    \\ (fn (asl, g) => let val rc = find_term TypeBase.is_record g in (
           assume_tac (cacheWrite_read_thm
              |> Q.ISPECL[`va:word64`, `pa:word48`, `^rc`, `pm:(word48->word8)`, `dc:(word48->CSET)`, `state:dharma8_state`]
	      |> SIMP_RULE(srw_ss())[LET_DEF]
	      |> PairedLambda.GEN_BETA_RULE)
       ) (asl, g) end)
   \\ rfs[(field_id_imp |> Q.ISPECL [`31n`, `data:bitstring`])]
   \\ CASE_TAC
   \\ PAIR_SPLIT_TAC
   \\ lfs[field_def]
   \\ fs[(v2w_fixwidth 
       |> INST_TYPE [alpha |-> ``:32``]
       |> Q.ISPECL[`(shiftr (SND (r:(word48 -> word8) # bitstring)) (0 :num))`]
       |> SIMP_RULE (srw_ss())[]) , shiftr_0]
);

val cache_write_read_WT_thm = Q.store_thm("cache_write_read_WT_thm", 
  `!(va:word64) (pa:word48) data:bitstring  (mc:MEM_CONFIG) (pm:(word48->word8)) (dc:(48 word -> CSET)) (dirty:bool) state. 
   let (mc',pm',dc') = write_cache(0w:word32, va, pa, data, mc, pm ,dc, dirty) state in 
   let (_, pm'') = write_mem(0w:word32, pa, data, mc', pm') in 
   let (_, _, vl)  = read_cache(0w:word32, va, pa, pm'', dc') state in 
     (LENGTH data = 32) ==>
     (v2w(data):word32  = v2w(vl))`,

    lrw[]
    \\ PairedLambda.GEN_BETA_TAC
    \\ fs_lambda_elim[read_cache_def, write_cache_def, write_mem_def]
    \\ rw[combinTheory.UPDATE_def] 
    \\ ntac 2 (ntac 4 (xfs [Once state_transformerTheory.FOR_def, state_transformerTheory.BIND_DEF]))
    \\ (fn (asl, g) => let val rc = find_term TypeBase.is_record g
        in assume_tac(cacheWrite_paHitdc'_thm |> Q.SPECL[`va`, `pa`, `^rc`, `pm`, `dc`, `state`] |> LET_ELIM_RULE) (asl, g) end)
    \\ fs_lambda_elim [CacheRead_def]
    \\ fs[combinTheory.UPDATE_def, Touch_def]  
    \\ (fn (asl, g) => let val rc = find_term TypeBase.is_record g
        in assume_tac (cacheWrite_read_thm  |> Q.SPECL[`va`, `pa`, `^rc`, `pm`, `dc`, `state`] |> LET_ELIM_RULE) (asl, g) end)
    \\ schneiderUtils.UNDISCH_HD_TAC
    \\ fs_lambda_elim[CacheRead_def]
    \\ fs[combinTheory.UPDATE_def, Touch_def, (field_id_imp |> Q.ISPECL [`31n`, `data:bitstring`])]
);


val cache_writeReq_readReq_thm = Q.store_thm("cache_writeReq_readReq_thm",
  `!(va:word64) (pa:word48) (cbl:word2) (data:bitstring) (ms:MEM_SYSTEM) (state:dharma8_state).
   let ms'    = writeReq(4n, cbl, va, pa, data, ms) state in
   let (_,vl) = readReq (4n, cbl, va, pa, ms') state in
     (LENGTH data = 32) ==>
     (v2w(data):word32  = v2w(vl))`,

       lrw[]
    \\ PairedLambda.GEN_BETA_TAC
    \\ fs_lambda_elim[writeReq_def, readReq_def]
    \\ rw[combinTheory.UPDATE_def]
    >- (imp_res_tac (cache_write_read_WB_thm |> LET_ELIM_RULE)
     \\ qpat_assum`!x.P`(qspecl_then[`va`, `state`, `ms.PM`, `pa`, `ms.MC`, `T`, `ms.CACHE`]assume_tac)
     \\ fs[])
    >-(imp_res_tac (cache_write_read_WT_thm |> LET_ELIM_RULE)
     \\ qpat_assum`!x.P`(qspecl_then[`va`, `state`, `ms.PM`, `pa`, `ms.MC`, `F`, `ms.CACHE`]assume_tac)
     \\ fs[])
    \\ fs[read_mem32_thm, write_mem32_thm2 |> spec_let_elim [`pa`, `data`, `ms.MC`, `ms.PM`],
              write_read_thm |> spec_let_elim [`pa`, `v2w data:word32`, `ms.PM`]]
);


    
val writeReq_NOTCHGconfigS_thm = Q.store_thm("writeReq_NOTCHGconfigS_thm", 
  `!(va:word64) (pa:word48) (cbl:word2) (data:bitstring) (ms:MEM_SYSTEM) (state:dharma8_state). 
   let ms' = writeReq (4n, cbl, va, pa, data, ms) state in 
      (ms.MC.S = ms'.MC.S)`,

       lrw[]
    \\ fs_lambda_elim[writeReq_def]
    \\ rw[combinTheory.UPDATE_def]  
    \\ EVERY[ntac 5 (fs_lambda_elim[write_cache_def, write_mem_def, Once state_transformerTheory.FOR_def, state_transformerTheory.BIND_DEF])]
);



